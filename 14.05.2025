import numpy as np
import matplotlib.pyplot as plt
from scipy.sparse import diags, kron, identity
from scipy.sparse.linalg import spsolve
from scipy.sparse import block_diag

# --- Henyey-Greenstein phase function ---
def henyey_greenstein(cos_theta, g):
    return (1 - g**2) / (1 + g**2 - 2 * g * cos_theta)**(3/2)

# --- Function to compute directional gradients ---
def compute_directional_gradients_2d(nx, ny, dx, dy):
    N = nx * ny  # Total number of grid nodes

    # --- Main directions ---
    # Right (M_x)
    main_diag_x = np.ones(N)
    lower_diag_x = -np.ones(N - 1)
    lower_diag_x[np.arange(1, N) % nx == 0] = 0
    M_x = diags([main_diag_x, lower_diag_x], [0, -1], format='csr') / dx

    # Left (M_-x)
    main_diag_neg_x = np.ones(N)
    upper_diag_x = -np.ones(N - 1)
    upper_diag_x[np.arange(N - 1) % nx == (nx - 1)] = 0
    M_neg_x = diags([main_diag_neg_x, upper_diag_x], [0, 1], format='csr') / dx

    # Up (M_y)
    main_diag_y = np.ones(N)
    lower_diag_y = -np.ones(N - ny)
    # lower_diag_y[:nx] = 0
    M_y = diags([main_diag_y, lower_diag_y], [0, -nx], format='csr') / dy

    # Down (M_-y)
    main_diag_neg_y = np.ones(N)
    upper_diag_y = -np.ones(N - nx)
    # upper_diag_y[-nx:] = 0
    M_neg_y = diags([main_diag_neg_y, upper_diag_y], [0, nx], format='csr') / dy

    # --- Diagonal directions ---
    M_diag_ur = (M_x + M_y) / np.sqrt(2)         # Up-Right (1,1)/√2
    M_diag_ul = (M_neg_x + M_y) / np.sqrt(2)     # Up-Left (-1,1)/√2
    M_diag_dl = (M_neg_x + M_neg_y) / np.sqrt(2) # Down-Left (-1,-1)/√2
    M_diag_dr = (M_x + M_neg_y) / np.sqrt(2)     # Down-Right (1,-1)/√2 


    return M_x, M_diag_ur, M_y, M_diag_ul, M_neg_x, M_diag_dl, M_neg_y, M_diag_dr


# --- Simulation parameters ---
nx, ny = 16, 16
Lx, Ly = 1.0, 1.0
dx, dy = Lx / (nx - 1), Ly / (ny - 1)

# absorption_coeff = 1.0  # Absorption coefficient
scattering_coeff = 50  # Scattering coefficient
g = 0.85 # Scattering anisotropy


# --- Directions encoded using basis (+x, -x, +y, -y) ---
directions = np.array([
    [1, 0, 0, 0],  # (1, 0)
    [1 / np.sqrt(2), 0, 1 / np.sqrt(2), 0],  # (1/√2, 0, 1/√2, 0)
    [0, 0, 1, 0],  # (0, 1)
    [0, 1 / np.sqrt(2), 1 / np.sqrt(2), 0],  # (0, 1/√2, 1/√2, 0)
    [0, 1, 0, 0],  # (0, -1)
    [0, 1 / np.sqrt(2), 0, 1 / np.sqrt(2)],  # (0, 1/√2, 0, 1/√2)
    [0, 0, 0, 1],  # (-1, 0)
    [1 / np.sqrt(2), 0, 0, 1 / np.sqrt(2)],  # (1/√2, 0, 0, 1/√2)
])


direction_new =  np.array([
    [1, 0],  # (1, 0)
    [1 / np.sqrt(2), 1 / np.sqrt(2)],  # (1/√2, 0, 1/√2, 0)
    [0, 1],  # (0, 1)
    [-1 / np.sqrt(2), 1 / np.sqrt(2)],  # (0, 1/√2, 1/√2, 0)
    [-1, 0],  # (0, -1)
    [-1 / np.sqrt(2),-1 / np.sqrt(2)],  # (0, 1/√2, 0, 1/√2)
    [0, -1],  # (-1, 0)
    [1 / np.sqrt(2), - 1 / np.sqrt(2)],  # (1/√2, 0, 0, 1/√2)
])
n_dirs = direction_new.shape[0]

k_matrix = np.zeros((n_dirs, n_dirs))
for i in range(n_dirs):
    for j in range(n_dirs):
        cos_theta = np.dot(direction_new[i], direction_new[j])
        k_matrix[i, j] = henyey_greenstein(cos_theta, g)
k_matrix /= np.sum(k_matrix, axis=1, keepdims=True)



# --- Create spatial grid ---
#x = np.linspace(0, Lx, nx)
#y = np.linspace(0, Ly, ny)
x = np.linspace(-Lx/2, Lx/2, nx)
y = np.linspace(-Ly/2, Ly/2, ny)
X, Y = np.meshgrid(x, y)

# --- Light source (Gaussian distribution) ---
q = 50 * np.exp(-100 * ((1/500)* X**2 + (Y - 0.45)**2))


# --- Get directional gradient operators ---
A_x, A_diag_ur, A_y, A_diag_ul, A_neg_x, A_diag_dl, A_neg_y, A_diag_dr = compute_directional_gradients_2d(nx, ny, dx, dy)

# --- Build system matrix ---
N = nx * ny

# --- Transport operators for each direction ---
A_directions = []
for vx, v_negx, vy, v_negy in directions:
    A_dir = (
        kron(diags([vx], [0]), A_x) +
        kron(diags([v_negx], [0]), A_neg_x) +
        kron(diags([vy], [0]), A_y) +
        kron(diags([v_negy], [0]), A_neg_y)
    )
    A_directions.append(A_dir)

# --- Spatially varying absorption coefficient ---
# abs_coeff_map = np.full_like(X, 0.5)

# abs_coeff_map = (0.5 + 0.5 * np.sin(2 * np.pi * X) * np.cos(2 * np.pi * Y))* 10
w_sigma = 0.3
abs_coeff_map = 0.2 * np.exp(-((X - 0.2)**2 + Y**2)/ (2 * w_sigma**2))

# abs_coeff_map = np.zeros_like(X)
# abs_coeff_map[(X**2 + Y**2) < 0.1**2] = 10.0


#abs_coeff_map = np.ones_like(X)
#abs_coeff_map[(X-0.5)**2 + (Y-0.5)**2 < 0.1**2] = 10.0
absorption_coeff_vector = abs_coeff_map.flatten()

# Combine all directional transport matrices
# A_directional = kron(identity(n_dirs), sum(A_directions))
A_directional = block_diag(A_directions, format='csr')

# --- Absorption and scattering operator ---
# A_abs_scatter = kron(identity(n_dirs), diags([absorption_coeff + scattering_coeff], [0], shape=(N, N)))
A_abs_scatter = kron(identity(n_dirs), diags([absorption_coeff_vector + scattering_coeff], [0], shape=(N, N)))

# --- Scattering redistribution operator ---
A_scatter = kron(k_matrix, diags([scattering_coeff], [0], shape=(N, N)))

# --- Final system matrix ---
A_total = A_directional + A_abs_scatter - A_scatter

#print("scater", k_matrix)
#print(diags([scattering_coeff], [0], shape=(N, N)))



def make_directional_source(q_base, direction_index, n_dirs):
    """
    Creates a source vector where the light is injected only in one direction.
    """
    q_vector = np.zeros((n_dirs, *q_base.shape))
    q_vector[direction_index] = q_base
    return q_vector.reshape(-1)


def plot_heatmap(matrix, title):
    """
    Visualize a sparse matrix as a heatmap.
    Converts it to dense and crops to size×size.
    """
    dense = matrix.toarray()[:100, :100]
    
    plt.figure(figsize=(8, 6))
    heatmap = plt.imshow(dense, cmap='viridis', interpolation='nearest', origin='upper')
    plt.title(f"Heatmap: {title}", fontsize=16, weight='bold', pad=15)
    plt.colorbar(heatmap, label='Intensity', orientation='vertical')
    plt.grid(False)
    plt.tick_params(axis='both', which='both', length=0)
    plt.tight_layout()
    plt.show()


# plot_heatmap(A_directional, "A_directional")
# plot_heatmap(A_abs_scatter, "A_abs_scatter")
# plot_heatmap(A_scatter, "A_scatter")
# plot_heatmap(A_total, "A_total")

def print_sparse_matrix(matrix, name):
    matrix = matrix.tocsr()  # in index format
    dense = matrix.toarray()  # in numpy form
    print(f"\n{name} ({dense.shape[0]}x{dense.shape[1]}):")
    print(dense)


# print_sparse_matrix(A_directional, "A_directional")
# print_sparse_matrix(A_abs_scatter, "A_abs_scatter")
# print_sparse_matrix(A_scatter, "A_scatter")
# print_sparse_matrix(A_total, "A_total")

# --- Solve the system ---
# q_vector = np.concatenate([q.flatten(), np.zeros((n_dirs - 1) * N)])
# Phi_flat = spsolve(A_total, q_vector)  # Solution as flat vector
# Phi = Phi_flat.reshape((n_dirs, ny, nx))  # Reshape to 3D
# Phi_total = Phi.sum(axis=0)  # Sum over all directions (fluence)

"""
# --- Visualization ---
plt.imshow(Phi_total, extent=(0, Lx, 0, Ly), origin='lower', cmap='hot')
plt.colorbar(label='Total Intensity Φ')
plt.title('Intensity Distribution (DOM, Henyey-Greenstein)')
plt.xlabel('x')
plt.ylabel('y')
plt.show()

# --- Plot directional intensities (Φ_i for each direction) ---
fig, axes = plt.subplots(2, 4, figsize=(18, 8))
direction_labels = [
    "→", "↗", "↑", "↖", 
    "←", "↙", "↓", "↘"
]

for i in range(n_dirs):
    ax = axes[i // 4, i % 4]
    im = ax.imshow(Phi[i], extent=(0, Lx, 0, Ly), origin='lower', cmap='plasma')
    ax.set_title(f"Direction {i+1}: {direction_labels[i]}", fontsize=12)
    ax.set_xlabel("x")
    ax.set_ylabel("y")
    plt.colorbar(im, ax=ax, fraction=0.046, pad=0.04)

plt.suptitle("Directional Intensities Φᵢ (per direction)", fontsize=16, weight='bold')
plt.tight_layout(rect=[0, 0.03, 1, 0.95])
plt.show()
"""

""""
Phi_total_all = np.zeros((ny, nx))

fig, axes = plt.subplots(2, 4, figsize=(20, 10), constrained_layout=True)
fig.suptitle('Φ_total from Directional Sources (DOM)', fontsize=20)

for i in range(n_dirs):
    q_vector = make_directional_source(q, direction_index=i, n_dirs=n_dirs)
    Phi_flat = spsolve(A_total, q_vector)
    Phi = Phi_flat.reshape((n_dirs, ny, nx))
    Phi_total = Phi.sum(axis=0)
    Phi_total_all += Phi_total

    ax = axes.flat[i]
    im = ax.imshow(Phi_total, extent=(0, Lx, 0, Ly), origin='lower', cmap='hot')
    ax.set_title(f"Direction {i + 1}", fontsize=14)
    ax.set_xlabel('x')
    ax.set_ylabel('y')

cbar = fig.colorbar(im, ax=axes, location='right', shrink=0.85, pad=0.02)
cbar.set_label('Φ_total')

plt.show()"""

""""
plt.figure(figsize=(8, 6))
plt.imshow(Phi_total_all, extent=(0, Lx, 0, Ly), origin='lower', cmap='hot')
plt.title('Φ_total from All Directions (Sum)', fontsize=16)
plt.xlabel('x')
plt.ylabel('y')
plt.colorbar(label='Φ_total (summed)')
plt.tight_layout()
plt.show()
"""

q_vector = make_directional_source(q, direction_index=6, n_dirs=n_dirs)
"""
q_vector = np.zeros((n_dirs, *q.shape))
for i in range(n_dirs):
    q_vector[i] = q
q_vector = q_vector.reshape(-1)
"""
Phi_flat = spsolve(A_total, q_vector)
Phi = Phi_flat.reshape((n_dirs, ny, nx))
Phi_total = Phi.sum(axis=0) * 2* np.pi/8 

plt.figure(figsize=(8, 6))
plt.imshow(Phi_total, extent=(-Lx/2, Lx/2, -Ly/2, Ly/2), origin='lower', cmap='hot')
plt.title('Intensity Distribution (DOM, Henyey-Greenstein)')
plt.colorbar()
plt.show()

# NEW PART

from skimage.restoration import denoise_tv_chambolle

# --- TV projection Q2: Total Variation denoising ---
def Q2_TV_denoise(a_vector, nx, ny, weight=0.1):
    a_image = a_vector.reshape(ny, nx)
    a_denoised = denoise_tv_chambolle(a_image, weight=weight, channel_axis=None)
    return a_denoised.flatten()

# --- Q1 projection: Project absorption onto piecewise-constant block space ---
def Q1_piecewise(a, nx, ny, block_size=4):
    a_proj = np.copy(a.reshape(ny, nx))
    for i in range(0, ny, block_size):
        for j in range(0, nx, block_size):
            block = a_proj[i:i+block_size, j:j+block_size]
            avg = np.mean(block)
            a_proj[i:i+block_size, j:j+block_size] = avg
    return a_proj.flatten()

# --- Forward solve: Compute fluence for given absorption vector ---
def solve_fluence(a_vector):
    A_abs_scatter = kron(identity(n_dirs), diags([a_vector + scattering_coeff], [0], shape=(N, N)))
    A_total = A_directional + A_abs_scatter - A_scatter

    Phi_flat = spsolve(A_total, q_vector)
    Phi = Phi_flat.reshape((n_dirs, ny, nx))
    Phi_total = Phi.sum(axis=0) * 2 * np.pi / n_dirs
    return Phi_total, Phi  # total fluence and all directional components

# --- Objective function (loss) ---
def compute_loss(a_vector, y_target):
    Phi_total, _ = solve_fluence(a_vector)
    pressure = a_vector.reshape(ny, nx) * Phi_total
    return 0.5 * np.linalg.norm(pressure.flatten() - y_target.flatten())**2

# --- Adjoint-based gradient computation ---
def compute_adjoint_gradient(a_vector, y_target):
    # Step 1: Forward solve to get Φ
    A_abs_scatter = kron(identity(n_dirs), diags([a_vector + scattering_coeff], [0], shape=(N, N)))
    A_total = A_directional + A_abs_scatter - A_scatter

    Phi_total, Phi_all = solve_fluence(a_vector)
    pressure = a_vector.reshape(ny, nx) * Phi_total
    residual = pressure - y_target.reshape(ny, nx)  # shape: (ny, nx)

    # Step 2: Right-hand side of adjoint: μ_a * residual
    rhs = (a_vector.reshape(ny, nx) * residual).flatten()
    rhs_expanded = np.tile(rhs / n_dirs, n_dirs)

    # Step 3: Solve adjoint equation A^T λ = RHS
    lambda_vec = spsolve(A_total.transpose(), rhs_expanded)

    # Step 4: Compute gradient: sum over Φ_i(x) * λ_i(x)
    grad = np.zeros_like(a_vector)
    for d in range(n_dirs):
        λ_d = lambda_vec[d*N:(d+1)*N]
        Φ_d = Phi_all[d].flatten()
        grad += Φ_d * λ_d

    # Step 5: Add ∂f/∂μ_a = Φ(x) * residual(x)
    grad += Phi_total.flatten() * residual.flatten()

    return grad

# --- Gradient descent optimization ---
def optimize_absorption(a_init, y_target, n_iter, alpha, block_size):
    a = a_init.copy()
    loss_history = []

    for it in range(n_iter):
        grad = compute_adjoint_gradient(a, y_target)
        a_new = a - alpha * grad

        a_q1 = Q1_piecewise(a_new, nx, ny, block_size)   # Q1: block averaging projection
        a = Q2_TV_denoise(a_q1, nx, ny, weight=0.01)     # Q2: TV denoising
        # a = Q1_piecewise(a_new, nx, ny, block_size)    # Uncomment to use only Q1 without TV

        loss = compute_loss(a, y_target)
        loss_history.append(loss)
        print(f"Iter {it+1:02d}: Loss = {loss:.6e}")

        if it > 0 and abs(loss_history[-1] - loss_history[-2]) < 1e-6:
            print(f"Early stopping at iteration {it+1}")
            break

    return a, loss_history 

# 1. Ground truth absorption map
a_true = absorption_coeff_vector.copy()

# 2. Generate synthetic target data (pressure field)
Phi_total_true, _ = solve_fluence(a_true)
y_target = a_true.reshape(ny, nx) * Phi_total_true

# 3. Run optimization
a_init = 0.1 * np.ones_like(a_true)
a_rec, losses = optimize_absorption(a_init, y_target, n_iter=100, alpha=0.01, block_size=2)

# 4. Plotting results
plt.figure(figsize=(16, 5))

plt.subplot(1, 3, 1)
plt.imshow(a_true.reshape(ny, nx), cmap='viridis')
plt.title("Ground truth $\mu_a$")
plt.colorbar()

plt.subplot(1, 3, 2)
plt.imshow(a_rec.reshape(ny, nx), cmap='viridis')
plt.title("Reconstructed $\mu_a$")
plt.colorbar()

plt.subplot(1, 3, 3)
plt.plot(losses, marker='o')
plt.title("Loss over iterations")
plt.xlabel("Iteration")
plt.ylabel("Loss")
plt.grid()

plt.tight_layout()
plt.show()

# 5. Quantitative evaluation: RMSE and PSNR
from sklearn.metrics import mean_squared_error

rmse = np.sqrt(mean_squared_error(a_true, a_rec))
psnr = 20 * np.log10(np.max(a_true) / rmse)

print(f"RMSE: {rmse:.5f}, PSNR: {psnr:.2f} dB")
